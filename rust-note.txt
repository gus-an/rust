RUST

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

RUST IS
- expression-based language
  - statement : perform action and 'do not' return a value
    - statement cannot be assigned to a variable
    - (ex) let x = (let y = 6)
    - (ex) x = y = 6
    - statement don't evaluate to a value, which is expressed by '()', an empty tuple
  - expression : evaluate to a resulting value
    - function / macro is an expression
    - expressions do not include ending semicolons
- needs to know at compile time what 'type' a variable is
  - 'if' and 'else' block cannot have different type
- gives you control over your memory usage, having the owner of data
  automatically clean up that data when the owner goes out of scope

RUST HAS
- strong, static type system
  - type must be known at compile time
  - four primary : integer, floating point, boolean, characters
- immutable variables as default
  - safety, easy concurrency
- snake_case as conventional style for 'function' and 'variable' names
- three kinds of loops
  - 'loop' : execute until explicitly told to stop with 'break'
    - use of 'loop' is to retry an operation you know might fail, 
      such as checking whether a thread has completed its job
    - you can return a value when you 'break'
  - 'while' : evaluate condition within a loop
  - 'for' : execute some code for each item in a collection
    - less error prone
    - more efficient, there isn't checking condition for each loop
    - most commonly used loop construct in Rust
- prevention for data races
  - very restricted allows for mutation
  - no two or more pointers access same data at same time


DEFINITIONS
- crate : packages of codes
- Cargo.lock : keeps track of exact versions of dependencies in project
  - created first time you ran 'cargo build'
  - when you build in future, Cargo will see 'Cargo.lock'
- Crates.io : where people in Rust ecosystem post their open source Rust projects
- trait: there are multiple traits in a crate (ex. rand::Rng, rand:Rand)
- shadowing : allows you to reuse a variable
  - creating a brand-new variable
  - use 'let' keyword again
  - different from 'mut' variables
    - has to use 'let' keyword
    - can change the type of value
- constants
  - use 'const' keyword
  - must be annotated
  - can be declared at any scope, including global
  - are valid for the entire time a program runs
  - may be set only to a contant expression (not result of a function call, or values computed at runtime)
- tuples
  - fixed length, cannot shrink or grow
- array
  - every element must have same type
  - has fixed length
  - helpful allocating data on stack (rather than heap)
    - array is single chuck of memory allocated on the stack.
- vector
  - allowed to grow or shrink
- function
  - doesn't matter where to define a function
  - parameter's 'type' must be declared
  - return value of the final expression(no semicolon) in the block of the body
    - you can return early by using 'return' keyword
- ownership
  - stack : fixed size
    - data are close to other data
    - when function is called, values passed to fn and fn's local variables are pushed onto stack
    - basic types are all stored on stack, and popped off when scope is over
  - heap : size that might change
    - OS finds empty spot in heap that is big enough, returns pointer
    - slower when accessing data, you have to follow a pointer
    - data are farther away from other data
  - ownership keeps track of what parts of code are using what data on heap,
  - minimize duplicate data on heap, clean up unused data on heap
  - Rules
    - 1. Each value in Rust has a variable that's called its 'owner'
    - 2. There can only be one owner at a time
    - 3. When the owner goes out of 'scope', the value will be dropped
  - Rust automatically return memory once the variable that owns it goes out of scope
    - pair exactly one 'allocate' with one 'free'
    - special function 'drop' is called when closing curly bracket
  - Rust will never automatically create 'deep' copy of your data
  - 'clone' : create deep copy of heap data
- string literals
  - immutable
  - know content at compile time, text is hardcoded into executable
  - fast and efficient
  - copy makes duplication on stack
  - let s = "hello world!"
    - type of 's' is '&str' : a slice pointing to specific point of binary
    - this is immutable reference -> reason why string literals are immutable
- String
  - able to store an amont of text that is unknown at compile time
  - allocate an amount of memory on the heap
    - memory must be requested from os at runtime (String::from)
    - need a way of returning this memory to os when done with it
  - 'move' : copy only copies pointer to memory, and invalidates original one
    - prevents 'double free error'
- 'copy' trait
  - 'copy' traits are stored on the stack
  - if a type has 'copy' trait, an older variable is still usable after assignment
  - all basic types are 'copy'
  - tuple of basic types are 'copy'
  - any type with 'drop' trait cannot be annotated as 'copy' trait 
- references
  - & ampersands : refer to some value without taking ownership of it
  - compiler guarantees references will never be dangling
    - will ensure that data will not go out of scope before the reference to it does
- dereference
  - * asterisk
- borrowing
  - having references as function parameters
  - cannot modify something's we're borrowing
- slice
  - does not have ownership
  - reference a contiguous sequence of elements in a collection rather the whole
  - internally, slice stores starting position, and length of the slice
  - helps to find error at compile time
- struct
  - custom data type that lets you name and package together multiple related values
  - more flexible than tuple, don't rely on order of data

CARG INSTRUCTION
- cargo new hello_cargo
- cargo build : compile -> build exe
  - --release : compile with optimizations
    - create exe in 'target/release', not 'target/debug'
    - use for benchmarking running time
- cargo check : compiles, don't build exe
- cargo run : build and run
- cargo update : ignore 'Cargo.lock' and figure out latest ver specified in 'Cargo.toml'
- cargo doc --open : build doc provided by all your dependencies and open a browser

TROUBLESHOOT
[1] Cargo.toml -> [dependencies] -> rand = "0.3.14" -> cargo build ����� ����.
- cmd �� ����� ��
- setx CARGO_HTTP_CHECK_REVOKE "false" �غ� ��